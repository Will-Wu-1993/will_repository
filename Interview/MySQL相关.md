### char和varchar的区别：  
&emsp;&emsp;varchar是可以变长的，char是定长的。如果数据是固定大小的，使用char会得倒更好的性能。
### TERUNCATE和DELETE的区别：  
&emsp;&emsp;DELETE命令从一个表中删除一行或多行，TRUNCATE命令永久的从表中删除每一行。

### MySQL储存引擎：  
1. InnoDB储存引擎：默认事务型引擎，支持奔溃后的安全恢复，支持行级锁，支持外键。
### 锁机制：  
- 共享锁：不堵塞，多个用户可以同一时间查询同一条数据，但不能写。
- 排他锁：一个写的锁会阻塞其他的写锁和读锁，只允许一个用户进行写入，防止其他用户读取到正在写入的数据。
### 锁的粒度：
- 表锁：开销最小，会锁定整张表。不会出现死锁。
- 行锁：最大程度的支持并发处理，但是也带来的最大的锁开销，会发生死锁的情况。**InnoDB就是行锁。**
### 索引：
&emsp;&emsp;在索引数据中快速定位到某一个索引，再查找这个索引对应的数据所在的磁盘文件地址，实现快速的查找数据。  

&emsp;&emsp;缩索引是排好序的数据结构。  

&emsp;&emsp;MySQL底层所用的索引数据结构是B+Tree。（B+树数据结构）。 

&emsp;&emsp;为什么不使用二叉树呢？如果索引字段在递增的字段，就会导致二叉树单边增长（顺序链表），没有提高搜索效率。  

&emsp;&emsp;为什么不适用红黑树呢？如果数据量大的话，导致树的高度很高，查询速度也是不快的。  

&emsp;&emsp;MySQL实际使用的是B+Tree数据结构，在非叶子节点不储存数据，只储存key（数据表的主键），叶子节点包含了完整的数据记录。  

&emsp;&emsp;InnoDB是聚集索引，推荐使用整形和自增的字段做key。

&emsp;&emsp;一次IO将key查出来放在内存中，在内存中查找key，因为在内存中处理数据比IO块很多，所以会提高效率。

索引还有Hash索引，会有Hash碰撞的问题，而且也不适合做范围查询。

### myisam和InnoDB的区别：
1. innoDB支持事务，myisam不支持。
2. innoDB支持行级锁（排他锁），myisam不支持。
3. innoDB支持外键，myisam不支持。
4. Myisam查出的数据的顺序和插入的顺序是一致的，InnoDB是拍好顺序的。
5. Myisam是非聚簇索引索引文件和数据文件是分开的2个索引文件（.frm .myi）1个数据文件(.myd)，innoDB是聚簇索引，索引和数据是在同一个文件的，一个索引文件(.frm)和一个索引和数据文件(.idb)。


### InnoDB为什么要用自增的主键索引


### 四种事务的隔离级别

| 隔离级别 | 脏读 | 不可重复读 | 幻读 |
| --- | --- | --- | --- |
| 未提交读 | 可能 | 可能 | 可能 |
| 已提交读 | 不可能 | 可能 | 可能 |
| 可重复读 | 不可能 | 不可能 | 可能 |
| 可串行化 | 不可能 | 不可能 | 不可能 |

**MySQL默认隔离级别时可重复读**
- 未提交读：允许脏读，也就是可能读取到其他会话种未提交事务修改的数据。
- 提交读：读取到已经提交的数据。
- 可重复读：可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别
- 串行读：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞。

1. 脏读：脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问的这个数据，然后使用了这个数据。
2. 不可重复读：是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一个数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的数据不一致。
3. 可重复读。
4. 幻读：第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据。同时，第二个事务也修改这个表中的数据，这种修改是想表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据，就好像发生幻觉一样。

### 事务的四大特性
1. 原子性：原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚。
2. 一致性：事务必须使数据库从一个状态换到另一个状态，也就是说一个事务执行前后都必须处于一致性状态。
3. 隔离性：当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要互相隔离。
4. 持久性：一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。

### MySQL优化
如何查看查询SQL是否使用了索引？
在查询索引前面加入 EXPLAIN
```sql
EXPLAIN SELECT * FROM 表名 WHERE 字段名 = '查询的内容';
```