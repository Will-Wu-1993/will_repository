#### 1. 什么是RabbitMQ
采用AMQP高级队列协议的一种消息队列技术，最大的特点就是消费并不需要提供方的存在，实现了服务之间的高度解耦。
#### 2. 为什么要使用RabbitMQ
1. 在分布式系统下具备异步，削峰，负载均衡等一系列高级功能；
2. 拥有持久化机制，进程消息，队列中的信息也可以保存下来；
3. 实现消费者和生产者之间的解耦；
4. 对于高并发场景下，利用消息队列可以使得同步访问变为串行访问达到一定量的限流。利于数据库操作；
5. 可以使用消息队列达到异步下单的效果，排队中，后台进行逻辑下单。
#### 3. 使用RabbitMQ的场景
1. 服务间异步通信
2. 顺序消费
3. 定时任务
4. 请求削峰
#### 4. 如何确保消息正确的发送至RabbitMQ？如何确保消息接收方消费了消息？
**发送方确认模式**
将信道设置成confirm模式（发送方确认模式），则所有在信道上发布的消息都会被指派一个唯一的ID。
一旦消息被投递到队列后，或者消息被写入磁盘后（可持久化的消息），信道会发送一个确认给生产者（包含消息的唯一ID）。
如果RabbitMQ发生内部错误从而导致消息丢失，会发送一条nack（notacknowledged，未确认）消息。
发送方确认模式是异步的，生产者应用程序在等待确认的同时，可以继续发送消息。当确认消息到达生产者应用程序，生产者应用程序的回掉方法就会被触发来处理消息。


**接收方确认机制**
消费者接受每一条消息后都必须进行确认（消息接受和消息确认是两个不同操作）。只有消费者确认了消息，RabbitMQ才能安全的把消息从队列中删除。
这里并没有用到超时机制，RabbitMQ仅通过Consumer（消费者）的连接中断来确认是否需要重新发送消息。也就是说，只要连续不中断，RabbitMQ给了Consumer足够长的时间来处理消息。保证数据的最终一致性；
几种特殊情况：
* 如果消费者接受到消息，在确认之前断开了连接或取消了订阅，RabbitMQ会认为消息没有被分发，然后重新分发给下一个订阅的消费者。（可能存在消息重复消费的隐患，需要去重）
* 如果消费者接受消息却没有确认消息，连接也未断开，则RabbitMQ认为该消费者繁忙，将不会给该消费者分发更多的消息。
#### 5. 如何避免消费重复投递或者重复消费？
在消息产生时，MQ内部针对每条生产者发送的消息生成一个inner-msg-id，作为去重的依据（消息投递失败并重传），避免重复的消息进入队列；在消息消费时，要求消息体中必须要有一个bizid（对于同一业务全局唯一，如支付ID、订单ID、帖子ID等）作为去重的依据，避免同一条消息被重复消费。
#### 6. 消息基于什么传输？
由于TCP连接的创建和开销较大，且并发数受系统资源限制，会造成性能瓶颈。RabbitMQ使用信道的方式来传输数据，信道是建立在真实的TCP连接内的虚拟链接，且每条TCP连接上的信道数量没有限制。
#### 7. 消息如何分发？
若该队列至少有一个消费者订阅，消息将以循环（round-robin）的方式发送给消费者。每条消息只会分发给一个订阅的消费者（前提是消费者能够正常处理消息并进行确认）。通过路由可实现多消费的功能。
#### 8. 消息是怎么路由
消息提供方-->路由-->一至多个队列消息发布到交换器时，消息将拥有一个路由键（routing key），在消息创建时设定。通过队列路由键，可以把队列绑定到交换器上。消息到达交换器后，RabbitMQ会将消息的路由键与队列的路由键进行匹配（针对不同的交换器有不同的路由规则）；
常用的交换器主要分为以下三种：
direct：如果路由键完全匹配，消息就被投递到相应的队列
fanout：如果交换器收到消息，将会广播到所有绑定的队列上
topic：可以使来自不同源头的消息能够达到同一个队列。使用topic交换器时，可以使用通配符。
#### 9. 如何确保消息不丢失？
消息持久化，当然前提是队列必须持久化，
RabbitMQ确保持久性消息能从服务器重启中恢复的方式是，将他们写入磁盘上的一个持久化日志文件，当发布一条持久性消息到持久交换器时，Rabbit会在消息提交到日志文件后才发送响应。一旦消费者从持久队列中消费了一条持久化消息，RabbitMQ会在持久化日志中把这条消息标记为等待垃圾手机。如果持久化消息被消费之前RabbitMQ重启，那么Rabbit会自动重建交换器和队列（以及绑定），并重新发布持久化日志文件中的消息到合适的队列。
#### 10. 使用RabbitMQ有什么好处？
1. 服务间高度解耦
2. 异步通信性能高
3. 流量削峰
#### 11. RabbitMQ的集群
镜像集群模式
你创建的queue，无论元数据还是queue里的消息都会存在于多个实例上，然后每次你写消息到queue的时候，都会自动把消息同步到多个实例的queue。
好处在于，你任何一个机器宕机，没事，别的机器都可以用。坏处在于，第一，这个性能开销太大，消息同步到所有机器，导致网络带宽压力和消耗很重，第二，没有扩展性科可言，如果某个queue负载很重，你加机器，新增的机器也包含了这个queue的所有数据，并没有办法线性扩展你的queue。